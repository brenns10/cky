<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CKY Parser: src/regex.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CKY Parser
   
   </div>
   <div id="projectbrief">A C implementation of a regex lexer with a CKY grammar parser.</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">src/regex.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Declarations for regular expression routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;libstephen/al.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="fsm_8h_source.html">fsm.h</a>&quot;</code><br/>
</div>
<p><a href="regex_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregex__hit.html">regex_hit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold regular expression search hits.  <a href="structregex__hit.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a620b076c4e97fc7c6e95600bd9f6fc39">regex_hit_init</a> (<a class="el" href="structregex__hit.html">regex_hit</a> *obj, int start, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>.  <a href="#a620b076c4e97fc7c6e95600bd9f6fc39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregex__hit.html">regex_hit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#af780fe7ad3fe1abdc77113d94cd85aa2">regex_hit_create</a> (int start, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>.  <a href="#af780fe7ad3fe1abdc77113d94cd85aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a38c12ce2ebc264d6b371e83396d45b02">regex_hit_destroy</a> (<a class="el" href="structregex__hit.html">regex_hit</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> object.  <a href="#a38c12ce2ebc264d6b371e83396d45b02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#abc7bd85bcf94515c25ecc6fd3c4508f4">regex_hit_delete</a> (<a class="el" href="structregex__hit.html">regex_hit</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up and free a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> object.  <a href="#abc7bd85bcf94515c25ecc6fd3c4508f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#ac6a448a418b078c44fb0d0d302431eba">regex_parse_check_modifier</a> (<a class="el" href="structfsm.html">fsm</a> *new, const wchar_t **<a class="el" href="main_8c.html#a43a8f57687aa2fc48598046c021ed7e9">regex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the FSM according to its modifier, if any.  <a href="#ac6a448a418b078c44fb0d0d302431eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a2c49189ca53918ba1e644d5c3d0a4fc1">regex_parse_create_whitespace_fsm</a> (int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a FSM that accepts any whitespace.  <a href="#a2c49189ca53918ba1e644d5c3d0a4fc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e56e4221f6f7b0abb6dda80395dba08"></a><!-- doxytag: member="regex.h::regex_parse_create_word_fsm" ref="a2e56e4221f6f7b0abb6dda80395dba08" args="(int type)" -->
<a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a2e56e4221f6f7b0abb6dda80395dba08">regex_parse_create_word_fsm</a> (int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a FSM for word characters (letters, numbers, and underscore). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d29a86b2059e1fb7aa3b05662eb1f88"></a><!-- doxytag: member="regex.h::regex_parse_create_digit_fsm" ref="a9d29a86b2059e1fb7aa3b05662eb1f88" args="(int type)" -->
<a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a9d29a86b2059e1fb7aa3b05662eb1f88">regex_parse_create_digit_fsm</a> (int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a FSM for digits. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a2b81fd55b1de3e8405c4e5d17dd7b63d">regex_parse_outer_escape</a> (const wchar_t **<a class="el" href="main_8c.html#a43a8f57687aa2fc48598046c021ed7e9">regex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an FSM for an escape sequence, outside of a character class.  <a href="#a2b81fd55b1de3e8405c4e5d17dd7b63d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a292a18ffe8a3ffa53aae02a662c04415">regex_parse_char_class</a> (const wchar_t **<a class="el" href="main_8c.html#a43a8f57687aa2fc48598046c021ed7e9">regex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a FSM for a character class.  <a href="#a292a18ffe8a3ffa53aae02a662c04415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfsm.html">fsm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a58c440b23a9f0be68aea919a81a5ca00">regex_parse</a> (const wchar_t *<a class="el" href="main_8c.html#a43a8f57687aa2fc48598046c021ed7e9">regex</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a FSM to accept the given regex.  <a href="#a58c440b23a9f0be68aea919a81a5ca00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">smb_al *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#a20107415f6769b987e6d7beee78ed478">fsm_search</a> (<a class="el" href="structfsm.html">fsm</a> *regex_fsm, const wchar_t *srchText, bool greedy, bool overlap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a regex-style search with an FSM on a search text.  <a href="#a20107415f6769b987e6d7beee78ed478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">smb_al *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regex_8h.html#ac5ffd8988768ff06b05465eda3025753">regex_search</a> (const wchar_t *<a class="el" href="main_8c.html#a43a8f57687aa2fc48598046c021ed7e9">regex</a>, const wchar_t *srchText, bool greedy, bool overlap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a regular expression on a search text.  <a href="#ac5ffd8988768ff06b05465eda3025753"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Declarations for regular expression routines. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Stephen Brennan</dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>Created Sunday, 18 May 2014</dd></dl>
<dl class="copyright"><dt><b>Copyright:</b></dt><dd>Copyright (c) 2014, Stephen Brennan. All rights reserved.</dd>
<dd>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Stephen Brennan nor the names of his contributors may be used to endorse or promote products derived from this software without specific prior written permission.</dd>
<dd>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL STEPHEN BRENNAN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </dd></dl>

<p>Definition in file <a class="el" href="regex_8h_source.html">regex.h</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a20107415f6769b987e6d7beee78ed478"></a><!-- doxytag: member="regex.h::fsm_search" ref="a20107415f6769b987e6d7beee78ed478" args="(fsm *regex_fsm, const wchar_t *srchText, bool greedy, bool overlap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smb_al* <a class="el" href="regex_8h.html#a20107415f6769b987e6d7beee78ed478">fsm_search</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsm.html">fsm</a> *&#160;</td>
          <td class="paramname"><em>regex_fsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>srchText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a regex-style search with an FSM on a search text. </p>
<p>The "regex-style search" runs the FSM starting at each character in the text. If the FSM ever enters an accepting state, then that is a potential match. The last potential match (if any) for every character in the text makes up the list of hits.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">regex_fsm</td><td>The FSM to search with. Not necessarily generated from a regular expression. </td></tr>
    <tr><td class="paramname">srchText</td><td>The text to search the FSM on. </td></tr>
    <tr><td class="paramname">greedy</td><td>When set to true, only returns one hit. Otherwise, returns all hits. </td></tr>
    <tr><td class="paramname">overlap</td><td>When set to true, allows overlapping hits. For instance, a search for "\w+" on "blah" would return blah, lah, ah, and h. Since this is usually undesirable, the recommended value is false. When false, the search will skip to the end of each hit and resume searching there. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array list (smb_al) of `regex_hit *` full of hits. Each hit must be individually freed when you're finished, as well as the array list itself. </dd></dl>

<p>Definition at line <a class="el" href="search_8c_source.html#l00064">64</a> of file <a class="el" href="search_8c_source.html">search.c</a>.</p>

</div>
</div>
<a class="anchor" id="af780fe7ad3fe1abdc77113d94cd85aa2"></a><!-- doxytag: member="regex.h::regex_hit_create" ref="af780fe7ad3fe1abdc77113d94cd85aa2" args="(int start, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregex__hit.html">regex_hit</a>* <a class="el" href="regex_8h.html#af780fe7ad3fe1abdc77113d94cd85aa2">regex_hit_create</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start location of the hit. </td></tr>
    <tr><td class="paramname">length</td><td>The end location of the hit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>. Must be freed with <a class="el" href="regex_2datastructs_8c.html#abc7bd85bcf94515c25ecc6fd3c4508f4" title="Clean up and free a regex_hit object.">regex_hit_delete()</a>. </dd></dl>

<p>Definition at line <a class="el" href="regex_2datastructs_8c_source.html#l00062">62</a> of file <a class="el" href="regex_2datastructs_8c_source.html">datastructs.c</a>.</p>

</div>
</div>
<a class="anchor" id="abc7bd85bcf94515c25ecc6fd3c4508f4"></a><!-- doxytag: member="regex.h::regex_hit_delete" ref="abc7bd85bcf94515c25ecc6fd3c4508f4" args="(regex_hit *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="regex_8h.html#abc7bd85bcf94515c25ecc6fd3c4508f4">regex_hit_delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregex__hit.html">regex_hit</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up and free a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> to free. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="regex_2datastructs_8c_source.html#l00082">82</a> of file <a class="el" href="regex_2datastructs_8c_source.html">datastructs.c</a>.</p>

</div>
</div>
<a class="anchor" id="a38c12ce2ebc264d6b371e83396d45b02"></a><!-- doxytag: member="regex.h::regex_hit_destroy" ref="a38c12ce2ebc264d6b371e83396d45b02" args="(regex_hit *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="regex_8h.html#a38c12ce2ebc264d6b371e83396d45b02">regex_hit_destroy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregex__hit.html">regex_hit</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean up a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a> object to clean up. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="regex_2datastructs_8c_source.html#l00073">73</a> of file <a class="el" href="regex_2datastructs_8c_source.html">datastructs.c</a>.</p>

</div>
</div>
<a class="anchor" id="a620b076c4e97fc7c6e95600bd9f6fc39"></a><!-- doxytag: member="regex.h::regex_hit_init" ref="a620b076c4e97fc7c6e95600bd9f6fc39" args="(regex_hit *obj, int start, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="regex_8h.html#a620b076c4e97fc7c6e95600bd9f6fc39">regex_hit_init</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregex__hit.html">regex_hit</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The (pre-allocated) <a class="el" href="structregex__hit.html" title="A struct to hold regular expression search hits.">regex_hit</a>. </td></tr>
    <tr><td class="paramname">start</td><td>The start location of the hit. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the hit. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="regex_2datastructs_8c_source.html#l00049">49</a> of file <a class="el" href="regex_2datastructs_8c_source.html">datastructs.c</a>.</p>

</div>
</div>
<a class="anchor" id="a58c440b23a9f0be68aea919a81a5ca00"></a><!-- doxytag: member="regex.h::regex_parse" ref="a58c440b23a9f0be68aea919a81a5ca00" args="(const wchar_t *regex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfsm.html">fsm</a>* <a class="el" href="regex_8h.html#a58c440b23a9f0be68aea919a81a5ca00">regex_parse</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a FSM to accept the given regex. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>Regular expression string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A FSM that can be used to decide the language of the regex. </dd></dl>

<p>Definition at line <a class="el" href="parse_8c_source.html#l00415">415</a> of file <a class="el" href="parse_8c_source.html">parse.c</a>.</p>

</div>
</div>
<a class="anchor" id="a292a18ffe8a3ffa53aae02a662c04415"></a><!-- doxytag: member="regex.h::regex_parse_char_class" ref="a292a18ffe8a3ffa53aae02a662c04415" args="(const wchar_t **regex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfsm.html">fsm</a>* <a class="el" href="regex_8h.html#a292a18ffe8a3ffa53aae02a662c04415">regex_parse_char_class</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t **&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a FSM for a character class. </p>
<p>Reads a character class (pointed by `*regex`), which it then converts to a single transition FSM.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>Pointer to pointer to location in string! </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FSM for character class. </dd></dl>

<p>Definition at line <a class="el" href="parse_8c_source.html#l00246">246</a> of file <a class="el" href="parse_8c_source.html">parse.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a448a418b078c44fb0d0d302431eba"></a><!-- doxytag: member="regex.h::regex_parse_check_modifier" ref="ac6a448a418b078c44fb0d0d302431eba" args="(fsm *new, const wchar_t **regex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="regex_8h.html#ac6a448a418b078c44fb0d0d302431eba">regex_parse_check_modifier</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsm.html">fsm</a> *&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t **&#160;</td>
          <td class="paramname"><em>regex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adjust the FSM according to its modifier, if any. </p>
<p>When a character, character class, or parenthesized regex is read in, it could be followed by the modifiers `*`, `+`, or `?`. This function adjusts the FSM for those modifiers, and adjusts the location pointer if one was present.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">new</td><td>The newly read in FSM. </td></tr>
    <tr><td class="paramname">regex</td><td>The pointer to the pointer to the location in the regex. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parse_8c_source.html#l00059">59</a> of file <a class="el" href="parse_8c_source.html">parse.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2c49189ca53918ba1e644d5c3d0a4fc1"></a><!-- doxytag: member="regex.h::regex_parse_create_whitespace_fsm" ref="a2c49189ca53918ba1e644d5c3d0a4fc1" args="(int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfsm.html">fsm</a>* <a class="el" href="regex_8h.html#a2c49189ca53918ba1e644d5c3d0a4fc1">regex_parse_create_whitespace_fsm</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a FSM that accepts any whitespace. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Positive or negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parse_8c_source.html#l00097">97</a> of file <a class="el" href="parse_8c_source.html">parse.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2b81fd55b1de3e8405c4e5d17dd7b63d"></a><!-- doxytag: member="regex.h::regex_parse_outer_escape" ref="a2b81fd55b1de3e8405c4e5d17dd7b63d" args="(const wchar_t **regex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfsm.html">fsm</a>* <a class="el" href="regex_8h.html#a2b81fd55b1de3e8405c4e5d17dd7b63d">regex_parse_outer_escape</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t **&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an FSM for an escape sequence, outside of a character class. </p>
<p>Basically, adds the ``, ``, ``, ``, ``, `` character classes to the already existing character escape sequences covered by <a class="el" href="str_8c.html#a2812a14f008e19005dec1ae9f31d0a93" title="Get an escaped character from the string source.">get_escape()</a>.</p>
<p>Expects that `*regex` points to the backslash in the escape sequence. Always returns such that `*regex` points to the LAST character in the escape sequence.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>Pointer to the pointer to the backslash escape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FSM to accept the backslash escape sequence. </dd></dl>

<p>Definition at line <a class="el" href="parse_8c_source.html#l00200">200</a> of file <a class="el" href="parse_8c_source.html">parse.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ffd8988768ff06b05465eda3025753"></a><!-- doxytag: member="regex.h::regex_search" ref="ac5ffd8988768ff06b05465eda3025753" args="(const wchar_t *regex, const wchar_t *srchText, bool greedy, bool overlap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">smb_al* <a class="el" href="regex_8h.html#ac5ffd8988768ff06b05465eda3025753">regex_search</a> </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>srchText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overlap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for a regular expression on a search text. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="search_8c.html#a20107415f6769b987e6d7beee78ed478" title="Perform a regex-style search with an FSM on a search text.">fsm_search()</a> For full details on the operation of the function. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>The regular expression to search for. </td></tr>
    <tr><td class="paramname">srchText</td><td>The text to search in. </td></tr>
    <tr><td class="paramname">greedy</td><td>Whether to return first result only. </td></tr>
    <tr><td class="paramname">overlap</td><td>Whether to allow overlapping matches. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="search_8c_source.html#l00143">143</a> of file <a class="el" href="search_8c_source.html">search.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun May 24 2015 02:59:17 for CKY Parser by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
