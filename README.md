# cky

## About

- Author: Stephen Brennan
- License: Revised BSD
- Library Dependencies: [libstephen](https://bitbucket.org/brenns10/libstephen)

## Rationale

After learning a lot about grammars and normal forms in my EECS 343 (Theoretical
Computer Science) class, I decided it would be a fun adventure to implement the
CKY parsing algorithm in C.  And, since nobody likes to specify their grammars
in CNF, I would also have to implement the algorithm to convert a grammar into
CNF.

## Theory

The CKY parsing algorithm is a `O(n^3)` algorithm that parses strings to answer
whether they can be generated by a context-free grammar, given in Chomsky Normal
Form.  Chomsky Normal Form is a form of a grammar with the following
restrictions: rules may be in the form `A --> b`, where `b` is a terminal, or `A
--> B C`, where `B` and `C` are nonterminals.  Any context-free grammar can be
represented in CNF.

There exist other parsing algorithms that run asymptotically faster.  However,
they cannot parse an arbitrary grammar.  Additionally, I'm mainly looking to
implement an algorithm I learned, not reinvent the wheel.

## Goals

I would like to get this project to the point where it can take as inputs a file
with a grammar specification, and lexical specifications for the terminals, and
a file to parse, and then parse the file and output accept or reject, along with
a parse tree if it accepts.  Perhaps it could even output the CKY table!

## Current State

- I have created a basic set of grammar structures for the project.  I have
  created the basic memory management routines that go along with them, but not
  much more.  I've decided that a lexical analyzer is an important part of the
  project.

- I have created a finite state machine structure for the project.  The FSM has
  the following parts implemented:
  - All memory management
  - Basic addition of states and transitions
  - Deterministic simulation
  - Import and export to text representations
  - Non-deterministic simulation

While it would be nice to have non-deterministic to deterministic conversion, it
is not very practical to spell out every possible input (in Unicode...) to every
single state, in order to figure out which states are distinct.  Although I'm
sure I could come up with a clever algorithm that could select only the
characters which are necessary, I don't want to deal with that just now.  Simply
simulating non-deterministic seems like it will likely do the job.

I'm aiming to create a regular expression parser with the FSM structures.  In
order to complete that, I'll need to create functions that will operate on FSM's
like so:

- Concatenate FSM's
- Place FSM's in parallel
- Kleene star

With these, I'm pretty sure I will have everything necessary to implement a
regex parser!
